TCP: Flow Control

TCP Sliding Window
    - allows:
        - segment delivery guarantee => detects segment lost, and allows the transmiter to retransmit
        - segment order guarantee => receiver reordering based on the SequenceNumber
        - transmission and reception rate synchronization (flow control) using "AdvertisedWindow" TCP segment field
    - Objective: define an "Effective Window" => measure that allows to adapt the transmiter pace to the receiver one


How delivery and order is guaranteed?

            Transmitter Application                                                 Receiver Application
    ------------------------------------------------------------------------------------------------------------------- TCP

                                LastByteWritten                                 LastByteRead         
                                ↓                                               ↓                                                       
    ──────────────────────────────────────                                  ──────────────────────────────────────
                │████████│██████│                                               │██████████│          │████│            Buffers (fulfill from left to right)
    ──────────────────────────────────────                                  ──────────────────────────────────────
                ↑        ↑                                                                 ↑               ↑
      LastByteAck        LastByteSent                                      NextByteExpected                LastByteRecvd


    - LastByteWritten => last byte written in the buffer by the TX_Application
    - LastByteSent => last byte sent to the receiver
    - LastByteAck => last byte acknowledged

    - all bytes before "LastByteAck" can be erased
    - all the info sent but not acknowledged must be keep in the buffer (LastByteAck > X <= LastByteSent) => in case retransmition is needed
    - all the info written but not sent (LastByteSent < X <= LastByteWritten) => info not retransmited yet

    - LastByteRead => last byte read by the receiver application
    - NextByteExpected => the next byte expected to receive
    - LastByteRecvd => last byte received from the transmitter

    - all info before "LastByteRead" can be erased from the buffer because the application already got it
    - there could be some lacks in the buffer of information not received yet, or maybe some information out of order => ordering occurs in the TCP Buffer
    - bytes < NextByteExpected can be acknowledged, but the rest not because even having some more information this will be disordered

    - following inequalities:
        - for TX:
            - LastByteAck <= LastByteSent
            - LastByteSent <= LastByteWritten
            - LastByteAck <= LastByteWritten
        - for RX:
            - LastByteRead < NextByteExpected
            - LastByteRead <= LastByteRecvd
            - NextByteExpected <= LastByteRecvd+1


    - both buffers have a MAXIMUM SIZE: MaxSenderBuffer and MaxRcvBuffer
    - at TX => LastByteWritten - LastByteAck <= MaxSenderBuffer
    - at RX => LastByteRcvd - LastByteRead <= MaxRcvBuffer

    - to avoid RX Saturation => AdvertisedWindow = MaxRcvBuffer - (LastByteRcvd - LastByteRead) => How much space is available in the RX Buffer?
    - TX must collaborate => EffectiveWindow = AvertiseWindow - (LastByteSent - LastByteAck) => How much bytes can TX sent and not collapse RX Buffer?

    - if EffectiveWindow = 0, TX can not sent any segment
    - if EffectiveWindow = 1, TX can send up to 1 MSS 